# ***********************************************************************************************
# Title   : 統計的因果推論の理論と実装
# Chapter : 5 回帰分析の基礎
# Date    : 2022/5/19
# Page    : P60 - P76
# URL     : https://github.com/mtakahashi123/causality
# ***********************************************************************************************


# ＜概要＞
# - 回帰分析は統計的因果推論の最も基本的な手段の1つなのでメカニズムを詳しく確認しておく
#   --- 相関係数が高くても必ずしも因果関係を示さない
#   --- 回帰分析は｢Xを原因｣｢Yを結果｣として想定して扱うことができる（｢想定｣である点に注意）


# ＜目次＞
# 0 準備
# 1 数値例で理解する最小二乗法
# 2 最小二乗法による切片と傾きの公式
# 3 条件付き期待値としての回帰モデル
# 4 残差平方和のシミュレーション


# 0 準備 -----------------------------------------------------------------------

# ライブラリ
library(tidyverse)
library(magrittr)
library(broom)


# 1 数値例で理解する最小二乗法 -----------------------------------------------------

# ＜ポイント＞
# - 母集団(N=5)から無作為抽出された標本(n=4)を想定する
# - 最小二乗法は残差を最小化することにより導出される
#   --- 残差をそのまま合計すると常にゼロになってしまう
#   --- 残差量を評価するため平方してプラスの値にして合計する（最後に1/2乗を適用して元に戻す）


# 標本データ
y1 <- c(40, 20, 50, 10)
x1 <- c(5, 1, 3, 2)

# プロット確認
plot(x1, y1)

# 推定値
# --- 係数は残差最小化のための具体例（回帰分析に基づくものではない）
yhat1 <- 11.143 + 6.857 * x1
yhat2 <- 10.909 * x1

# 残差
e1 <- y1 - yhat1
e2 <- y1 - yhat2

# 残差合計
# --- 残差が相殺されて適切に評価できない
e1 %>% sum()
e2 %>% sum()

# 残差平方の合計
e1^2 %>% sum()
e2^2 %>% sum()


# 2 最小二乗法による切片と傾きの公式 --------------------------------------------------

# ＜ポイント＞
# - 最小二乗法は解析的に係数を算出することができる
#   --- 公式によるアプローチは実務で使うことはない（プロセスは一度確認しておく）


# 標本データ
y1 <- c(40, 20, 50, 10)
x1 <- c(5, 1, 3, 2)

# 標本平均
xbar <- x1 %>% mean()
ybar <- y1 %>% mean()

# 平均偏差
hensa_x <- x1 - xbar
hensa_y <- y1 - ybar

# 傾きの計算（分子）
hensa_xy <- hensa_x * hensa_y
num <- hensa_xy %>% sum()

# 傾きの計算（分母）
hensa_x2 <- hensa_x^2
denom <- hensa_x2 %>% sum()

# 公式による計算
# --- 傾き：6.857143
# --- 切片：11.14286
b1 <- num / denom
b0 <- ybar - b1 * xbar

# 関数による計算
# --- 公式の計算と一致
model <- lm(y1 ~ x1)
model %>% tidy()

# 原点をとおる傾き
# --- 10.90909
ybar / xbar


# 3 条件付き期待値としての回帰モデル --------------------------------------------------

# ＜ポイント＞
# - 回帰モデルの指定値が条件付の平均値といわれる意味を考える
#   --- 同じXの値におけるYが複数点ある場合は平均値が推定値となる


# データ定義
y2 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
x2 <- c(1, 1, 1, 2, 2, 2, 3, 3, 3)

# Yの平均値
y2 %>% mean()

# モデル構築
# --- 傾き：3  切片：-1
model_2 <- lm(y2 ~ x2)
model_2 %>% summary() %>% use_series(coefficient)

# 推定値の計算
-1 + 3 * 1
-1 + 3 * 2
-1 + 3 * 3

# プロット作成
# --- 散布図と回帰直線
# --- 規則的なプロットである点に注意
plot(x2, y2)
abline(model_2)

# XごとのYの平均値
# --- 推定値と平均値が一致している
(1 + 2 + 3) / 3
(4 + 5 + 6) / 3
(7 + 8 + 9) / 3


# 4 残差平方和のシミュレーション -------------------------------------------------------

# ＜ポイント＞
# - 最小二乗法で残差平方和の最小化が成立していることはモンテカルロシミュレーションでも確認できる
#   --- モンテカルロ法は数式変形して求める厳密法ではなく、乱数から近似解を求める方法
#   --- 解析的に厳密解を得ること難しい状況でも解を得ることができる


# データ定義
x3 <- c(5, 1, 3, 2)
y3 <- c(40, 20, 50, 10)

# モデル構築
model_3 <- lm(y3 ~ x3)

# パラメータ取得
# --- 切片
# --- 傾き
aOLS <- model_3 %>% tidy() %>% pull(estimate) %>% .[1]
bOLS <- model_3 %>% tidy() %>% pull(estimate) %>% .[2]

# 残差平方和
ussOLS <- model_3 %>% resid() %>% raise_to_power(2) %>% sum()


# モンテカルロシミュレーションによる残差平方和の算出
# --- 切片はモデルからの取得値を使用
# --- 傾きは一様乱数より生成（無情報分布）
# --- 推定値から残差平方和(uss)を算出
b1 <- NULL
uss <- NULL
set.seed(1)
for (i in 1:10000) {
  a1 <- aOLS
  b1[i] <- runif(1, -10, 25)
  yhat <- a1 + b1[i] * x3
  uss[i] <- sum((y3 - yhat)^2)
}

# 残差平方和の比較
# --- シミュレーションの最小値
# --- モデルからの取得値
uss %>% min()
ussOLS

# プロット作成
# --- シミュレーション結果から二次関数のプロット集合を取得
# --- 最小値に縦線（2つはほぼ一致している）
# --- 残差(uss)の最小値におけるb1が回帰係数となっている（6.857143）
plot(b1, uss, col = 8, cex = 0.1, pch = 20)
abline(v = bOLS, lty = 1)
abline(h = ussOLS)
